BLADE TEMPLATE.

#Intro

File blade template menggunakan extensi '.blade.php'.
File blade template biasanya disimpan di direktori 'resource/views'
View blade bisa di return langsung dari route ataupun method controller menggunakan global helper function 'view()'.
Seperti yang sudah dijelaskan pada materi view, kita bisa mengirimkan data ke view, dengan menjadikanya sebagai argument ke dua dari global helper function view(). contoh :

    Route::get('/test', function(){
        return view('test', ['data' => 'hello test']);
    });

#Menampilkan Data

Untuk menampilkan data di blade template, kita bisa gunakan tanda double kurung kurawal ({{  }}).
Sebagai contoh, misalkan data dikirim dari Route sebagai berikut :

    Route::get('/test', function(){
        return view('test', ['data' => 'hello test']);
    });

Selanjutnya untuk menampilkanya di view test.blade.php, kita bisa lakukan berikut :

    {{ data }}

Statement echo dari blade template yaitu double kurung kuraawal ({{  }}), secara otomatis akan menjalankan function 'htmlspecialchars()' untuk mencegah serangan XSS.
Selain itu, statement echo blade template juga bisa menampilkan hasil dari function php apapun. sehingga memungkinkan kita untuk menuliskan function php apapun di dalam statement echo blade template. contoh :

    hari ini tanggal {{ date("d-m-y") }}

#Mendaftarkan Components Package Secara manual.

saat kita ingin membangun package yang memanfaatkan component blade, kita harus mendaftarkan nama class, dan tag html alias secara manual ke dalam method boot dari service provider package.
cara mendaftarkanya ada 2 macam, yaitu menggunakan method 'component('tag-alias', NamaClass::class)'. contoh

Blade::component('alert', Alert::classs);

atau menggunakan componentNamepace('Contoh\\Namespace\\Random', 'tag-alias');

contoh cara menggunakanya : <x-alert/>
kelebihan dari method componentNamespace adalah ketika didalam package terdapat lebih dari 2 namespace kita bisa menggunakan semuanya. contoh :

<x-alert::alertsatu/>
<x-alert::alertdua/>

# Merender Component.

Untuk menampilkan component, kita bisa menggunakan tag component blade di salah satu template blade.
Tag component blade, dimulai dengan string 'x-' selanjutnya diikuti dengan nama class component yang ditulis dengan format camel-case. contoh :

    <x-alert/>

jika class component berada di direktori yang lebih dalam dari direktori 'app/View/Components', kita bisa menggunakan tanda titik (.) untuk mengindikasi direktori bersarang.
sebagai contoh, misal component input berada di direktori 'app/View/Components/Forms/Input.php', kita bisa merendernya dengan menuliskanya sebagai berikut :

    <x-forms.input/>
Jika kita ingin merender component secara kondisional, kita bisa melakukanya dengan mendefinisikan method 'shouldRender()' di dalam component class kita. Jika method shouldRender mengembalikan false, maka component tidak akan dirender. contoh :

    public function shouldRender(): bool
    {
        return Str::length($this->message)>0;
    }

# Index Components

Mungkin terkadang kita memiliki / ingin mengelompokan component yang cocok kedalam sebuah grup. contoh :

    App\View\Components\Card\Card
    App\View\Components\Card\Header
    App\View\Components\Card\Footer

saat kita lihat contoh diatas, mungkin kita berpikir bahwa untuk merender component 'card' kita harus menggunakan '<x-card.card/>'.
Tapi kita tidak harus melakukan hal tersebut, didalam laravel ketika nama component sama dengan nama direktori component, maka laravel secara otomatis akan menganggap nama component sebagai akar (root) dari component tersebut. dan memungkinkan kita untuk merender component tersebut tanpa perlu mengulang namanya. contoh :

    <x-card>
        <x-card.head>...</x-card.head>
        <x-card.footer>...</x-card.footer>
    </x-card>

# Mem-passing data ke Component.

Kita bisa memberikan / mem-passing data ke component menggunakan attribut string HTML yang mana harus diawali / menggunakan prefix karakter titik dua (:).
contoh :

    <x-alert :message="$message"/>

Selanjutnya kita harus mendefinisikan semua data attribute component ke constructor class.
Semua properti public dari component akan secara otomatis tersedia (available) di view component, tanpa harus kita mengirimkanya ke view melalui method render dari component.
contoh :

    namespace App\View\Components;

    use Illuminate\View\Component;
    use Illuminate\View\View;

    class Alert extends Component {

        public function __construct(
            public string $type,
            public string $message
        ) {}

        public function render()
        {
            return view('components.alert');
        }
    }

Selanjutnya jika kita ingin menampilkan konten dari variable public component, kita bisa meng-echokan nama variabel tersebut.
contoh :

    <div class"alert alert-{{ $type }}" >
        {{ $message }}
    </div>

# Case
Saat menuliskan argument constructor component, kita harus menggunakan format CamelCase, sedangkan disaat kita menuliskan nama argument didalam attribut HTML, gunakan format kebab-case.
contoh :

    public function __construct(stirng $alertType) {}

kemudian disaat kita ingin menggunakanya di attribut HTML, kita bisa menuliskanya sbb :

    <x-alert alert-type="danger" />

#Short Attribute Syntax
Saat kita mem-passing attribute ke component, kita juga bisa menggunakan syntax short attribute.
Ini lebih nyaman digunakan, karena nama attribute akan mencocokan nama variabel yang sesuai dengan mereka.
contoh :

    // ini menggunakan syntax short attribute
    <x-profile :$userId :$name />

    // syntax diatas, itu sama dengan syntax berikut :
    <x-profile :user-id = "$userId" :name = "$name" />

#Escaping Attribute Render
Beberapa Framework Javascript juga menggunakan awalan tanda titik dua (:).
Jika kita ingin memberitahu blade, bahwa attribute tersebut bukan merupakan expresion PHP, kita bisa menggunakan awalan double titik dua (::).
contoh :

    <x-button ::class={ danger: isDeleting } />
        Submit
    </x-button>

    kode diatas akan dirender menjadi :

    <button :class="{ danger: isDeleting }">
        Submit
    </button>

# Component method
Selain variabel public yang tersedia di template component, semua method public juga dapat dipanggil di template component.
contoh :

    misalkan kita punya method berikut :

    public function isSelected(string $option): bool
    {
        return $option === $this->selected;
    }

selanjutnya kita bisa memanggil method tersebut dari template component, dengan memanggilnya sebagai variabel dengan nama yang sesuai dengan nama method.
contoh :

    <option {{ $isSelected($value) ? 'selected' : '' }} value="{{ $value }}">
        {{ $label }}
    </option>

#Accessing Attributes & Slots Within Component class
Blade component memungkinkan kita untuk mengakses nama component, attribut, dan slot dari dalam method render dari class component.
Untuk bisa mengakses data tersebut, kita harus mengembalikan closure function didalam method render.
contoh :

    public function render(): Closure
    {
        return function() {
            return "<div {{ $attributes }}>Components content</div>":
        }
    }

Method render ini juga bisa menerima data yang berisi array, dimana data ini merupakan satu satunya argument dari method ini.
Data array berisi beberapa element yang menyediakan informasi tentang component.
contoh :

    public function render(): Closure
    {
        return function($data) {
            // $data['componentName'];
            // $data['attributes'];
            // $data['slot'];

            return "<div {{ $attributes }}>Components content</div>":
        }
    }

'componentName' itu sama dengan nama tag HTML yang ada setelah tanda 'x-'. contoh componentName untuk '<x-alert class="alert-success" id="alert" />' adalah 'alert'.
'attributes' itu berisi semua attribute yang ada di tag HTML, misal dalam contoh diatas adalah : ['class=>alert-success', 'id=>alert'].
'slot' adalah sebuah object 'Illuminate\Support\HtmlString' dengan dengan content dari component slot.
function closure harus mengembalikan string, lalu jika string yang dikembalikan itu sesuai dengan view yang ada, maka view tersebut akan di render, jika tidak maka string akan dirender sebagai blade view inline.

NOTE : Jangan pernah mengembed data element yang ada di $data secara langsung ke string yang di return oleh method render, karena hal tersebut dapat memungkinkan eksekusi kode jarak jauh melalui content attribut yang berbahaya.

# Dependencies Tambahan.
- Jika component kita membutuhkan dependencies dari service container, kita bisa me-list dependencies yang dibutuhkan sebelum setiap data attribute dari component kita.nantinya secara otomatis dependencies akan disuntikan ke container.
contoh :

    public function __construct(
        public AlertCreator $alertCreator;
        public string $type;
        public string $message;
    ){}

# Menyembunyikan Methods / Properties.
- Jika kita ingin mencegah method / properti public kita terekspos sebagai variabel di template component kita, kita bisa menambahkanya ke properti array $expect dari component kita.
contoh :

    class Alert extends Components
    {
        // masukan properti / method yang ingin kita hide
        protected $expect = ['type'];

        public function __construct(
            public string $type;
        ){}
    }

# Attribute Components
 - Semua attribute HTML yang tidak didefinisikan di constructor dari class component, akan tersedia di 'attribute bag' dari component. Dan bisa diakses melalui variabel $attributes. Semua attribute dapat dirender didalam component dengan meng-echo variabel ini.
 contoh :

    // component alert
    <x-alert :message="$message" type="error" class="mt-4" />

    // blade component
    <div {{ $attributes }} >
        <-- content compponent -->
    </div>

# Attributes Default / Merge
- Ketika kita mungkin ingin menentukan nilai default, atau menggabungkan beberapa nilai ke attributes component, kita bisa gunakan method 'merge()' dari attributes bag. Method ini sangat berguna khususnya untuk menetapkan seperangkat class CSS default yang harus selalu di terapkan ke sebuah component.
contoh :

    // misalkan kita punya component blade berikut :
    <div {{ $attributes->merge(['class' => 'alert alert-'. $type]) }} >
        {{ $message }}
    </div>

    // Jika kita asumsikan component di gunakan sebagai berikut :
    <x-alert type="error" :message="$messages" class="mb-4" />

    // maka hasil render nya adalah sebagai berikut :
    <div class="alert alert-error mb-4" >
        <!--- Content dari $message ---!>
    </div>

# Merge Class secara Kondisional.
- Ketika mungkin kita ingin menggabungkan(merge) class berdasarkan kondisi tertentu, 'true' misalnya. Kita bisa gunakan method 'class()' dari attributes bags.
- Method ini menerima sebuah argument berupa data array, yang mana key-nya berupa list class yang ingin di merge, dan value-nya adalah expresion boolean(true/false).
- Jika array key, berupa numeric, maka dia akan selalu disertakan ketika class di render.
- contoh :

    <div {{ $attributes->class(['p-4', 'bg-red' => $hasErrors]) }} >
        {{ $messages }}
    </div>

- Selanjutnya, jika kita ingin me-merge(menggabungkan) attribute lain ke component, kita bisa merangkaikan method 'merge()' ke method 'class()'.
- contoh :

    <div {{ $attributes->class(['p-4', 'bg-red' => $hasErrors])->merge(['type' => 'button']) }} >
        {{ $messages }}
    </div>

- Jika kita ingin meng-compile element HTML secara kondisional yang tidak menerima attributes 'merge', kita bisa menggunakan directive '@class'.

# Menggabungkan Attribute Non Class
- Ketika kita melakukan penggabungan (merging) terhadap attribute yang bukan class, maka nilai yang disediakan untuk atrribute tersebut akan dipertimbangkan sebagai nilai default.
- Dan tidak seperti attribute class, yang akan menggabungkan nilai yang ada dengan nilai yang disuntikan, attribute non-class akan mengoverwrite(menimpa) nilai yang ada dengan nilai yang disuntikan / diberikan.
- contoh :

    // misalkan kita punya blade component berikut :
    <div {{ $attributes->merge(['type' => 'button']) }}>
        {{ $slot }}
    </div>

    // selanjutnya kita ingin mengcustom tipe button menjadi type submit misalkan, kita bisa tentukan saat menggunakan component, contoh :
    <x-button type="submit">
        Submit
    </x-button>

    // maka hasil yang akan dirender :
    <button type="submit">
        Submit
    </button>

- Jika kita ingin attribute selain attribute class juga memiliki nilai default, yang tidak akan di overwrite ketika ada nilai yang diinject-an ke dalam attributes tersebut maka kamu bisa menggunakan method 'prepends()'.
- contoh :

    // pada contoh berikut, attribute method-controller akan selalu memiliki nilai default 'profile-controller' dan nilai tambahan yang diinject-an ke attribute tersebut akan di letakan setelah nilai defaultnya yaitu 'profile-controller'.
    <div {{ $attributes->merge(['data-controller' => $attributes->prepends('profile-controller')]) }}>
        {{ $slot }}
    </div>

# Menerima & Memfilter Attributes.
- Jika kita ingin memfilter attributes, kita bisa menggunakan method 'filter()'.
- Method ini menerima sebuah function closure, yang mana harus mengembalikan boolean 'true' jika kita ingin attributes-nya tetap dipertahankan di attributes bags / variabel $attributes.
- contoh :

    // contoh blade template
    <div {{ $attributes->filter(fn(string $value, string $key) => $key == 'foo') }}>
        {{ $slot }}
    </div>

    // contoh penggunaan component
    <x-component foo="bar" class="mb-4" id="testId" />

    // hasil render :
    <div foo="bar">
        <!-- content component --!>
    </div>

- Selain itu kita juga bisa mem-filter / mengambil attributes hanya yang memiliki awalan tertentu menggunakan method 'whereStartWith()'
- contoh :

    // contoh blade component
    <div {{ $attributes->whereStartWith('wire:') }} >
        {{ $slot }}
    </div>

    // contoh penggunaan component :
    <x-component wire:model="email" wire:loading.class="opacity-50" class="mb-4" />

    // hasi render :
    <div wire:model="email" wire:loading.class="opacity-50">
        <!-- content component --!>
    </div>

- Selanjutnya kita juga bisa mengecualikan attributes tertentu agar tidak disertakan, menggunakan method 'whereDoesntStartWith()'.
- contoh :

    // contoh blade component
    <div {{ $attributes->whereDoesntStartWith('wire:') }} >
        {{ $slot }}
    </div>

    // contoh penggunaan component :
    <x-component wire:model="email" wire:loading.class="opacity-50" class="mb-4" />

    // hasi render :
    <div class="mb-4">
        <!-- content component --!>
    </div>

- dengan method 'first()' kita bisa mengambil attributes pertama yang ada didalam attributes bag yang ada.
- contoh :

    // contoh blade component
    <div {{ $attributes->whereStartWith('wire:')->first() }} >
        {{ $slot }}
    </div>

    // contoh penggunaan component :
    <x-component wire:model="email" wire:loading.class="opacity-50" class="mb-4" />

    // hasi render :
    <div wire:model="email">
        <!-- content component --!>
    </div>

- selain itu kita juga bisa memeriksa apakah suatu attribute itu ada dalam sebuah component / tidak, yaitu dengan menggunakan method 'has()'.
- Method ini menerima sebuah argument berupa nama attribute, yang merupakan satu2nya argument-nya.
- method ini mengembalikan nilai boolean (true/false) yang akan mengindikasikan ada /tidaknya attribute dalam component tersebut.
- contoh :

    @if($attributes->has('class'))
        <div>Class attribute ada.</div>
    @endIf

- kemudian ketika method 'has()' diberikan argument berupa data array, yang berisi beberapa nama attributes, maka dia akan memeriksa apakah setiap nama attributes yang ada dalam array tersebut, ada didalam component.
- contoh :

    @if($attributes->has(['class', 'id']))
        <div>Semua attributes ada dalam component.</div>
    @endIf

- jika kita ingin memeriksa apakah salah satu dari attributes yang diberikan itu ada didalam component, kita bisa menggunakan method 'hasAny()'.
- contoh :

    @if($attributes->hasAny(['class', 'id', 'name']))
        <div>Salah satu attribute, ada dalam component.</div>
    @endIf

- lalu jika kita ingin mengambil nilai attribute tertentu, kita bisa menggunakan method 'get()'.
- contoh :

    {{ $attributes->get('class') }}

- method 'only()' bisa digunakan untuk mengambil attributes tertentu yang sesuai dengan key yang diberikan.
- contoh :

    {{ $attributes->only('class') }}
    // akan mengambil attributes dengan key / nama class

- terakhir jika kita ingin mengambil semua attributes dalam component, kecuali attributes tertentu, kita bisa menggunakan method 'except()'.
- contoh :

    {{ $attributes->except(['class']) }}
    // akan mengambil semua attributes kecuali attributes 'class'

# Keyword yang dicadangkan (Reserved Keyword).
- Terdapat beberapa keyword yang dicadangkan / tidak bisa kita gunakan untuk mendefinisikan properti public / nama method didalam component,karena keyword tersebut digunakan untuk penggunaan internal didalam blade.
- Berikut beberapa keyword yang dicadangkan / tidak bisa digunakan :

    - resolveView
    - view
    - shouldRender
    - render
    - withName
    - withAttributes
    - data

# Slots
- Slot digunakan untuk memberikan content tambahan ke component.
- Untuk merender slot, bisa dilakukan dengan meng-echokan $slot.
- contoh :

    <div class='alert alert-danger'>
        {{ $slot }}
    </div>

- Untuk memberikan data ke slot, kita bisa lakukan dengan menyuntikan content di dalam component.
- contoh :

    <x-alert>
        <strong>Bahaya !</strong> ini adalah peringatan bahaya.
    </x-alert>

- Terkadang juga sebuah component harus merender beberapa slots yang berbeda di lokasi yang berbeda didalam component.
- contoh :

    <span class="alert-title">{{ $title }}</span>

    <div class="alert alert-dangert">
        {{ $slot }}
    </div>

- kita bisa mendefinisikan konten dari slot yang memiliki nama (dalam contoh diatas adalah $title) menggunakan tag 'x-slot'.
- Setiap content yang tidak berada didalam tag 'x-slot' secara explisit, akan dimasukan ke dalam variabel $slot.
- dari blade component diatas, maka kita bisa menggunakan componentnya sbb :

    <x-alert>
        <x-slot:title>
            Server Error
        </x-slot>

        <strong>Error !</strong> terjadi kesalahan.
    </x-alert>

- Selanjutnya kita juga bisa memeriksa apakah suatu slot itu berisi content / tidak menggunakan method 'isEmpty()'.
- contoh :

    <span class="alert-title">{{ $title }}</span>

    <div class="alert alert-dangert">
        @if (isEmpty($slot))
            Ini adalah content default.
        @else
            {{ $slot }}
        @endIf
    </div>

- sebagai tambahan, kita juga bisa menggunakan method 'hasActualContent()' untuk menentukan apakah sebuah slot itu berisi konten actual, artinya content-nya bukan berupa sebuah comment HTML.
- contoh :

     <span class="alert-title">{{ $title }}</span>

    <div class="alert alert-dangert">
        @if (isEmpty($slot))
            @if($slot->hasActualContent())
                Konten ini tidak mengandung comment HTML.
            @endIf
            Ini adalah content default.
        @else
            {{ $slot }}
        @endIf
    </div>

# Scoped Slot
- Kita bisa mengakses properti dan atau method dari component didalam slot.
- Dengan syarat properti atau method dari component tersebut harus didefinisikan secara public.
- Selanjutnya kita bisa mengakses properti / method dari component melalui variabel '$component'.
- contoh :

    // misalkan component Alert disini memiliki method public formatAlert().
    <x-alert>
        <x-slot:title>
            {{ $component->formatAlert('Server Error') }}
        </x-slot>

            <strong>Error !</strong> terjadi kesalahan.
    </x-alert>

# Attributes Slot
- Seperti juga blade component, kita juga bisa memberikan attribute tambahan ke dalam slot, contoh nama class CSS.
- contoh :

    <x-alert>
        <x-slot:title class="mb-3 border">
            {{ $component->formatAlert('Server Error') }}
        </x-slot>

            <strong>Error !</strong> terjadi kesalahan.
    </x-alert>

- Untuk berinteraksi dengan attributes slot, bisa dilakukan dengan menggunakan properti attributes dari nama variabel slot.
- contoh :

    <div {{ $attributes->class(['border']) }}>
        <h3 {{ $heading->attributes->class(['fw-bold']) }}>
            {{ $heading }}
        </h3>

        {{ $slot }}

        <footer->attributes->class(['text-secondary'])>
            {{ $footer }}
        </footer>
    </div>

# Inline Component View
- Ketika sebuah component itu sangat kecil, tentu kurang praktis ketika kita harus mengatur class dan blade component. Untuk alasan ini, kita bisa langsung me-return kode html langsung dari blade component di method render dari class component.
- contoh :

    public function render()
    {
        return <<< 'blade'
            <div class="alert alert-danger">
                {{ $slot }}
            </div>
        blade;
    }

# Generate Inline View Component
- Untuk membuat inline view di component, kita bisa menambahkan option '--inline' pada saat menjalankan perintah artisan 'php artisan make:component.
- contoh :

    php artisan make:component Alert --inline

# Dynamic Component.
- Terkadang mungkin kita harus me-render sebuah component, akan tetapi kita tidak tahu component mana yang harus dirender, sampai saatnya runtime.
- Untuk mengatasi ini kita bisa menggunakan 'dynamic-component' dari component bawaan laravel untuk melakukan render, berdasarkan nilai / variabel yang diberikan.
- contoh :

    <x-dynamic-component :component="$componentName" class="mb-4"/>

# Mendaftarkan Component Secara Manual.
- Umumnya semua component yang kita buat akan berada di direktori App/View/Components dan /resources/views/components.
- Akan tapi ketika kita ingin membangun sebuah package yang memanfaatkan blade component dari laravel, atau menempatkan component di direktori non-convensional.
- Agar laravel tau dan bisa menemukan component tersebut, kita harus mendaftarkanya secara manual, dengan cara mendaftarkan class component dan tag aliasnya.
- Untuk mendaftarkanya kita bisa lakukan di method boot dari Service Provider dari package ktia.
- contoh :

    public function boot(): void
    {
        Blade::component('custom-alert', CustomAlert::class);
    }

- setelah component kita telah di daftarkan, kita bisa mengakses / menggunakan component tersebut dengan :

    <x-custom-alert />

- terkadang pula package component yang kita buat itu berisi lebih dari 1 component, karena itu kita bisa menggunakan method 'componentNamepace' untuk mendaftarkan / load class component secara convensional.
- misalkan kita memiliki package CustomAlert yang memiliki component AlertDanger dan AlertInfo, kita bisa mendaftarkanya dengan cara berikut.
- contoh :

    public function boot(): void
    {
        Blade::componentNamepace('CustomAlert\\Views\\Components', 'customAlert');
    }

- karena kita telah mendaftarkanya kita bisa mengakses component dari package CustomeAlert sbb :

    <x-custom-alert:alert-danger />
    <x-custom-alert:alert-info />

# Anonymous Component
- Anonymous component itu mirip dengan inline component views, dia memiliki mekasnisme untuk mengatur component dengan satu file tunggal.
- Bedanya, anonymous component menggunakan satu file view dan tidak terkait dengan class component.
- Untuk mendefinisikan anonymous component, kita hanya perlu menempatkan blade component kita di direktori 'resources/views/components'.
- Sebagai contoh, misalkan kita punya anonymous component sbb : 'resources/views/components/alert.blade.php', kita bisa menggunakan / memanggil component dengan cara :

    <x-alert />

- Selanjutnya jika component berada di dalam subfolder misal 'resources/views/components/alerts/error.blade.php', maka kita bisa gunakan tanda titik (.) untuk mengindikasikanya.
- contoh :

    <x-alets.error />

# Index Anonymous components
- Terkadang suatu component itu terbuat dari beberapa template blade.
- Dan mungkin terkadang kita ingin mengelompokan template2 tersebut didalam sebuah direktori / folder.
- Contoh kita memiliki component accordion dengan struktur direktori berikut :

    /resources/views/components/accordion.blade.php
    /resources/views/components/accordion/item.blade.php

- dari struktur direktori component accordion diatas, kita bisa me-render component menggunakan <x-accordion /> dengan cara berikut :

    <x-accordion>
        <x-accordion.item>
            {{ $slot }}
        </x-accordion.item>
    </x-accordion>

- Tapi dalam render component accordion menggunakan <x-accordion /> kita akan dipaksa untuk menempatkan file index dari template component kita(accordion.blade.php) di direktori component (resources/views/components), bukan di direktori accordion(/resources/views/components/accordion).
- Untungnya Blade memungkinkan kita untuk menempatkan file yang namanya sesuai dengan nama direktori dari component didalam direktori component itu sendiri.
- Sehingga ketika file ini (file yang namanya sesuai dengan nama direktori component) itu ada, dia akan dijadikan sebagai element root dari component tersebut.
- contoh :

    /resources/views/components/accordion/accordion.blade.php
    /resources/views/components/accordion/item.blade.php

- Dengan struktur direktori diatas, kita tetap bisa me render component melalui <x-accordion /> sama seperti sebelumnya.

# Properties & Attributes Data Anonymous components
- Karena anonymous component tidak memiliki class apapun yang terkait, mungkin kita akan bingung bagaimana cara kita membedakan data mana yang diberikan ke component sebagai variabel dan attribut mana yang harus ditempatkan di component bags.
- Untuk menangani hal ini, kita bisa menggunakan directives '@props([])' untuk menentukan data yang akan dipertimbangkan sebagai variabel, dibagian atas dari template blade component.
- Semua attribute lain (selain data yang ada di props) akan disimpan di attributes bags.
- Selain itu jika kita ingin memberikan nilai default untuk variabel, kita bisa melakukanya dengan menjadikan nama variabel sebagai array key, dan nilai dari variabel sebagai array value.
- contoh :

    @props(['type'=>'info', 'message']);

    <div {{ $attributes->merge(['class' => 'alert alert-' . $type]) }}>
        {{ $message }}
    </div>

- selanjutnya kita bisa menggunakan / memanggil component sebagai berikut :

    <x-alert type="success" :message="Berhasil menambahkan data." class="mb-4" />

# Mengakses data Component Induk di component Anak (child)
- Ketika mungkin component kita nantinya sangat komplek, yang terdiri dari component parent (induk) dan child (anak), kita mungkin ingin mengakses data dari component induk didalam component anak.
- contoh :

    // misalkan kita punya component menu yang terdiri dari <x-menu> dan <x-menu.item > seperti ini :
    <x-menu color="blue">
        <x-menu.item>...</x-menu.item>
        <x-menu.item>...</x-menu.item>
    </x-menu>

    // selanjutnya untuk impelementasi dari component induk (<x-menu>) misal seperti ini :
    @props(['color' => 'red']);

    <ul {{ $attributes->merge(['class'=>'bg-' . $color . '-200']) }}>
        {{ $slot }}
    </ul>

- karena data props color hanya didefinisikan di component induk (parent), maka data ini tidak akan bisa diakses di component anak (child).
- tapi jika kita mendefinisikan menggunakan directive '@aware([])' maka data color akan bisa diakses di component anak (child).

# Path Anonymous Component
- Seperti yang telah dijelaskan sebelumnya, bahwa untuk membuat anonymous component, kita hanya perlu membuat template blade di direktori 'resources/views/components/'.
- Tapi bisa jadi kita ingin mendaftarkan path direktori component lain, ke dalam aplikasi laravel kita sebagai tambahan.
- Untuk melakukan hal ini, kita bisa menggunakan method 'anonymousComponentPath()'.
- method anonymousComponentPath menerima argument pertama sebagai lokasi dari component.
- method ini biasanya di didefinisikan di dalam method 'boot()' dari salah satu Service Provider aplikasi laravel kita.
- contoh :

    public function boot(): void
    {
        Blade::anonymousComponentPath(__DIR__ . '/../components');
    }

- Setelah method sudah di definisikan, dan misalkan kita memiliki component di direktori kita dengan nama 'panel.blade.php', maka kita bisa merender component tersebut sbb:

    <x-panel />

- Selanjutnya method ini juga menerima argument ke 2 yang bersifat opsional.
- Argument ke 2 dari method ini bisa kita isi dengan namespace yang nantinya akan menjadi prefix untuk component yang bersangkutan.
- contoh :

    // misalkan kita memberikan argument ke 2 ini nilai : 'dashboard'
    public function boot(): void
    {
        Blade::anonymousComponentPath(__DIR__ . '/../components', 'dashboard');
    }

- Maka jika kita memiliki file dengan nama yang sama seperti sebelumnya, kita bisa merender component tersebut dengan :

    <x-dashboard::panel />

# Membangun Layouts
# Mendefinisikan layouts menggunakan component.
- Hampir semua web-app itu menggunakan layout umum yang sama di semua halaman aplikasinya.
- Ini akan sangat merepotkan jika kita terus mengulang mendefinisikan layout yang sama di seluruh halaman dari aplikasi / disetiap view yang kita buat.
- Untungnya kita bisa mendefinisikan layout ini sebagai blade component tunggal, dan selanjutnya kita bisa menggunakanya di seluruh aplikasi.
- Sebagai contoh misalkan kita sedang membangun sebuah aplikasi todolist, mungkin layouts dari aplikiasi kita akan terlihat sbb :

    <!-- resources/views/components/layout.blade.php -->
    <html>
        <head>
            <title>{{ $title ?? 'Todo App Web' }}</title>
        </head>

        <body>
            <h1>Todo : </h1>
            </hr>
            {{ $slot }}
        </body>
    </html>

- Setelah kita mendefinisikan layout seperti diatas, selanjutnya kita bisa menggunakan layout tersebut.
- Misalkan kita ingin menampilkan list dari todo kita, menggunakan view task kita, seperti ini :

    <x-layout>
        @foreach($tasks as $task)
            <div>{{ $task }}</div>
        @endforeach
    </x-layout>

- Yang perlu kita ingat adalah, bahwa setiap konten yang kita inject(suntikan) didalam component, akan disediakan sebagai variabel $slot default.
- Tapi jika kita perhatikan ulang, kita tahu bahwa di dalam component layout terdapat slot $title yang mana akan disediakan jika diberi nilai, dan akan menampilkan nilai default jika tidak diberi nilai.
- Jika kita ingin memberikan nilai ke variabel slot $title dari view task kita, kita bisa menggunakan syntax slot seperti yang sudah pernah dibahas di bab sebelumnya.
- contoh :

    <x-layout>

        <x-slot:title>
            Custom Judul
        </x-slot>

        @foreach($tasks as $task)
            <div>{{ $task }}</div>
        @endforeach

    </x-layout>

# Layout Menggunakan Pewarisan Template.
# Mendefinisikan Layout
- Sebelum mengenal component pembuatan layout menggunakan pewarisan template (template inheritence) adalah jalan utama dalam pembangunan aplikasi web.
- Untuk memulai membangun layout menggunakan pewarisan template kita akan menggunakan sebuah contoh sederhana.
- contoh layout template (parent):

    <!-- resources/views/layouts/app.blade.php -->
    <html>
        <head>
            <title>Nama App - @yield('title')</title>
        </head>
        <body>
            @section('sidebar')
                <p>Bagian ini sidebar utama</p>
            @show

            <div class="container">
                @yield('content')
            </div>
        </body>
    </html>

- Jika diperhatikan layout diatas terdapat directive @yield() dan @section.
- Directive @section digunakan untuk mendefinisikan bagian(section) dari konten.
- Sedangkan @yield digunakan untuk menampilkan konten dari section yang ditentukan / diberikan.

# Meng-Extends Layouts.
- Untuk menggunakan layout yang telah kita buat, kita harus mendefinisikan directive @extends() di view child (anak) dan menentukan layout induk(parent) yang ingin kita gunakan / warisi.
- View yang sudah meng-extends blade layout dapat menyuntikan konten ke dalam layout yang di extends dengan menggunakan directive @section().
- Dan perlu diingat bahwa, seperti contoh diatas, content dari section akan ditampilkan menggunakan directive @yield yang berada di view layout.
- contoh extends view :

    <!-- resources/views/child.blade.php -->
    @extends('layouts.app')

    @section('title', 'Judul Halaman')

    @section('sidebar')

        @@parent

        <p>Bagian ini akan ditambahkan ke sidebar utama.</p>

    @endsection

    @section('content')
        <p class="">Ini adalah bagian dari content.</p>
    @endsection

- Pada contoh diatas, dibagian sidebar, kita menggunakan directive @@parent untuk menambahkan (alih alih menimpa) content dari sidebar di layout.
- Directive @@parent akan digantikan oleh konten yang ada di layout ketika view ini di render.
- Jika kita perhatikan, berbeda dengan sidebar di layout, sidebar di child view menggunakan directive @endsection, sedangkan di parent view menggunakan @show.
- Perbedaanya adalah @endsection hanya akan mendefinisikan bagian dari content, sedangkan @show akan mendefinisikan dan segera menghasilkan bagian dari kontent.
- Directive @yield juga menerima parameter ke2 sebagai nilai default, dimana parameter ini akan di render ketika section (bagian) yang di-yield-kan itu undefined(tidak ditemukan).
- contoh :

    // pada contoh berikut 'Judul Halaman' akan dirender jika section title tidak didefinisikan.
    @yield('title', 'Judul Halaman')

# Forms
# CSRF Field
- Setiap kita membuat form HTML di dalam aplikasi laravel kita, kita harus menyertakan sebuah field hidden untuk token CSRF.
- Dengan adanya field tersebut middleware perlindungan CSRF di aplikasi laravel kita bisa memvalidasi request yang masuk.
- Kita bisa menggunakan directive blade @csrf untuk menghasilkan field CSRF.
- contoh :

    <form method="POST" action:"/user/profile">
        @csrf

        ...

    </form>

# Field Method
- Karena form HTML tidak dapat membuat request PUT, DELETE, atau PATCH, maka kita bisa gunakan field hidden (tersembunyi) _method() untuk memalsukan HTTP verbs ini.
- Untuk membuatnya kita bisa menggunakan directive blade @method.
- contoh :

    <form method="POST" action:"/user/profile">
    @method('PUT')

        ...

    </form>

# Kesalahan (Errors) Validasi
- Directive @error dapat kita gunakan untuk memeriksa secara cepat, jikalau ada pesan error validasi untuk attribute yang ditentukan.
- Selain itu kita juga bisa menampilkan pesan error didalam directive @error dengan meng-echo variabel $message.
- contoh :

    <input
        id="title"
        type="text"
        class="@error('title') is-invalid @enderror"
    />

    // menampilkan pesan error dengan meng-echo variabel $message
    @error('title')
        <div class="alert alert-danger" >{{$message}}</div>
    @enderror

- Karena directive @error ini mengcompile ke sebuah statement 'if', maka kita bisa menambahkan directive @else ditengah tengahnya, ketika kita ingin merender sesuatu saat tidak ditemukan error dalam form untuk suatu attribute.
- contoh :

    <input
        id="title"
        type="text"
        class="@error('title') is-invalid @else is-valid @enderror"
    />

- Directive @error juga menerima parameter kedua yang bisa kita isikan dengan nama spesific dari error bag, jika kita ingin mengambil pesan error dari halaman yang berisi beberapa form / banyak form.
- contoh :

    // contoh dibawah, menambahkan parameter berupa error bag bernama 'login'
    <input
        id="title"
        type="text"
        class="@error('title', 'login') is-invalid @enderror"
    />

    // menampilkan pesan error dengan meng-echo variabel $message
    @error('title', 'login')
        <div class="alert alert-danger" >{{$message}}</div>
    @enderror

# Stacks
- Blade memungkinkan kita untuk melakukan push (mendorong) stack bernama ke lokasi lain dari view atau layout lainya.
- Hal ini sangat berguna ketika kita ingin menspesifikan library JS / CSS untuk view child.
- contoh :

    // misalkan kita punya layout berikut :
    <html>
        <head>
            <title>My Web</title>
            @stack('script')
        </head>

        <body>
            @yield('content')
        </body>
    </html>

    // Selanjutnya didalam view child kita bisa melakukan push ke @stack('script'), seperti berikut :

    @extends('layouts.app.')

    @section('content')
        <p>Hello World</p>
    @endsection

    @push('script')
        <script>console.log('ini adalah script yang di push dari stack bernama.')</script>
    @endpush

- Selain itu jika kita ingin melakukan push ketika nilai boolean bernilai true, kita bisa menggunakan @pushIf.
- contoh :

    // jika nilai dari variabel $condition bernilai true, maka script akan dipush.
    @pushIf($condition, 'script')
        <script>console.log('ini adalah script yang di push dari stack bernama.')</script>
    @endpush

- Seperti contoh diawal untuk me-render stack yang sudah di push kita bisa menggunakan directive @stack('namaStack').
- contoh :

    <head>
        ...

        @stact('script')
    </head>

- Selanjutnya jika kita ingin stack yang kita push berada di posisi paling awal / pertama, kita bisa gunakan directive @prepend('namaStack').
- contoh :

    @push('stack1')
        <script>console.log("ini akan berada setelah prepend.")</script>
    @endpush

    @prepend('stack')
        <script>console.log("ini akan berada di paling awal.")</script>
    @endprepend

# Service Injection
- Ketika kita ingin mengambil sebuah service dari service container laravel di dalam blade, kita bisa menggunakan directive blade @inject().
- Argument pertama dari directive @inject adalah nama variabel yang menjadi tempat disimpanya service yang ingin kita ambil, sedangkan argument ke 2 adalah nama interface / class yang ingin kita ambil (resolve).
- contoh :

    // misalkan kita ingin mengambil class Userservice dan menyimpanya di variabel $user. kita bisa melakukanya dengan :
    @inject('users', 'App\Model\User')

    @foreach($users as $user)
        {{ $user }}
    @endforeach

# Merender Template Blade Inline.
- Terkadang kita mungkin harus merender string dari template blade mentah kita (mentah = belum diconvert menjadi kode HTML) menjadi kode HTML yang valid.
- Untuk melakukanya kita bisa memanfaatkan method render() dari facade Blade.
- Method ini menerima 2 parameter, parameter pertama adalah string dari template blade, sedangkan parameter ke2 adalah data array yang disediakan untuk template blade dan ini bersifat opsional.
- contoh :

    Blade::render ('Hai {{ $nama }}', ['nama' => 'Dunia']);

- Laravel merender template blade inline dengan cara menuliskanya di direktori / folder 'storage/framework/views'.
- Selanjutnya jika kita ingin menghapus temporary file setelah kita melakukan rendering inline blade template, kita bisa menambahkan argument 'deleteCachedView' dengan value 'true' ke method render, sebagai argument ke 3.
- contoh :

    Blade::render ('Hai {{ $nama }}', ['nama' => 'Dunia'], deleteCachedView: true);

# Render Fragment Blade.
- Saat menggunakan framework frontend seperti htmx atau Turbo, terkadang kita harus me-return hanya bagian tertentu dari blade template di HTTP Response.
- Untuk melakukan ini, kita bisa menggunakan directive blade @fragment.
- Caranya kita hanya perlu menempatkan bagian dari blade template yang akan kita return diantara directive @fragment dan @endfragment.
- contoh :

    @fragment('user-list')
        <ul>
            @foreach($users as $user)
                <li>{{ $user }}</li>
            @endforeach
        </ul>
    @endfragment

- Selanjutnya ketika kita ingin merender view yang memanfaatkan template ini, kita harus memanggil method 'fragment()' untuk menentukan bahwa hanya fragment yang sudah ditentukan saja yang boleh disertakan keluar bersama HTTP Response.
- contoh :

    return response()->view('dashboard', ['users' => $user])->fragment('user-list');

- Jika kita ingin me return fragment dari view berdasarkan kondisi tertentu, kita bisa menggunakan directive fragmentIf(). Jika kondisi yang diberikan tidak terpenuhi, maka seluruh view akan di return.
- contoh :

    return response()->view('dashboard',['users' => $users])->fragmentIf($request->hasHeader('HX-Request'), 'user-list');

- Dengan method fragment() dan fragmentIf() kita juga bisa me-return multiple fragment di response. contoh :

    view('dashboard', ['users' => $users])
    ->fragments(['user-list', 'comment-list']);

    view('dashboard', ['users' => $users])
        ->fragmentsIf(
            $request->hasHeader('HX-Request'),
            ['user-list', 'comment-list']
        );

# Extending Blade
- dengan Blade kita bisa membuat custom directive milik kita sendiri.
- Cara kerjanya adalah, ketika compiler Blade bertemu dengan custom directive kita, dia akan memanggil callback yang disediakan beserta dengan expression yang terkandung didalam directive tersebut.
- Sebagai contoh, contoh berikut membuat directive @datetime($var) yang mana akan memformat variabel $var yang diberikan dan harusnya menjadi instance dari DateTime.

    class AppServiceProvider extends ServiceProvider
    {
        public function register(): void
        {
            ...
        }

        public function boot(): void
        {
            Blade::directive('datetime', function(string $expression){
                return "<?php echo ($expresion)->format('m/d/Y H:i'); ?>";
            });
        }
    }

- Pada contoh diatas, kita merangkaikan method format ke expresion apapun yang diberikan ke directive.
- Sehingga final PHP yang dihasilkan akan menjadi :

    <?php echo ($var)->format("m/d/Y H:i") ?>

- note :
    - setelah kita memperbarui logic dari directive blade, kita harus menghapus semua blade view yang di cache.
    - Untuk melakukanya kita bisa gunakan perintah artisan 'view:clear'

# Mengcustom Echo Handler.
- Saat kita mencoba meng-echo sebuah object menggunakan blade, sebuah method bernama __toString() akan dipanggil.
- Method __toString() adalah salah satu 'magic method' bawaan PHP.
- Tapi terkadang kita tidak memiliki kendali atas method '__toString()' dari object yang diberikan, seperti contoh mungkin object yang sedang berinteraksi dengan kita berasal dari partisi pihak ke 3.
- Pada kasus seperti ini, Blade memungkinkan kita untuk mendaftarkan custom echo handler kita sendiri untuk jenis object tertentu.
- Untuk melakukanya kita bisa memanggil method 'stringable()' milik Blade. method ini menerima sebuah closure.
- Di dalam closure tersebut kita harus mengetikan tipe object yang bertugas melakukan rendering.
- dan Terakhir method stringable ini biasanya didefinisikan di method boot dari AppServiceProvider aplikasi laravel kita.
- contoh :

    use Illuminate\Support\Facades\Blade;
    use Money\Money;

    public function boot(): void
    {
        Blade::stringable(function (Money $money) {
            return $money->formatTo('en_GB');
        });
    }

- Setelah kita sudah mendefinisikan custom echo handler kita sendiri, kita bisa menggunakanya sesimpel echo object di blade template.
- contoh :

    Cost : {{ $money }}

# Custom Statement if
- Blade juga menyediakan method Blade::if() yang bisa kita gunakan untuk membuat custom directive pengkondisian.
- Method ini menerima nama directive sebagai perameter pertama, dan closure pada parameter kedua.
- function closure menerima argument yang diterima oleh directive.
- contoh :

    Blade::if('disks', function(string $value){
        return config('filesystems.default') === $value;
    });

- Setelah kita mendefinisikan custom directive pengkondisian kita, kita bisa menggunakanya.
- contoh  :

    @disks('local')

    @elsedisks('s3')

    @else

    @enddisks

    @unlessdiks('local')

    @enddisks
