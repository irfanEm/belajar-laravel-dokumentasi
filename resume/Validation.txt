# Pengelanan / Intro.
- Laravel menyediakan beberapa pendekatan yang berbeda untuk melakukan validasi terhadap data yang masuk ke aplikasi laravel kita.
- Yang paling umum adalah menggunakan method validat() yang tersedia di semua HTTP Request.
- Tapi pada pembahasan kali ini kita juga akan membahas pendekatan lain yang juga digunakan untuk melakukan validasi.
- Laravel menyertakan berbagai macam aturan validasi yang nyaman, yang bisa kita terapkan ke data, bahkan menyediakan kemampuan untuk melakukan validasi apakah suatu nilai dari table database itu unique.
- Pada pembahasan ini akan membahas setiap aturan validasi secara detail sehingga kita akan familiar dengan semua fitur validasi laravel.

# Quickstart validasi.
- Untuk mempelajari tentang fitur validasi laravel yang powerfull ini, kita akan melihat pada contoh validasi lengkap pada sebuah form dan menampilkan kembali pesan error ke user.
- Dengan membaca gambaran umum level tinggi ini, diharapkan kita bisa mendapatkan pemahaman dasar yang baik tentang bagaimana cara memvalidasi request yang masuk menggunakan laravel.

# Definisikan Route.
- Pertama mari kita asumsikan bahwa kita telah memiliki / mendefinisikan route berikut di file routes/web.php aplikasi laravel kita :

    use App\Http\Controller\PostController;

    Route::get('/post/create', [PostController::class, 'create']);
    Route::post('/post', [PostController::class, 'store']);

- Route 'get' akan menampilkan form ke user untuk membuat postingan blog baru, sedangkan Route 'post' digunakan untuk menyimpan postingan blog baru ke database.

# Membuat Controller.
- Selanjutnya mari kita lihat pada controller yang menangani request yang masuk ke route ini, dan untuk sementara kita akan membiarkan method store() kosong.

    <?php
    namespace App\Http\Controllers;

    class PostController extends Controller
    {
        public function create(): View
        {
            return view('post.create');
        }

        public function post(Request $request): RedirectResponse
        {
            // memvalidasi request
            $post = /** .. */
            return to_route('post.show',['post' => $post->id]);
        }
    }

# Menulis Logik Validasi.
- Sekarang saatnya kita mengisi method store() dengan logik yang digunakan untuk memvalidasi postingan blog baru.
- Kita akan menggunakan method validate() yang disediakan oleh object Illuminate\Http\Request.
- Jika aturan validasi lolos, maka kode kita akan dieksekusi secara normal, jika gagal, maka sebuah exception Illuminate\Validation\ValidationException akan di lempar(throw) dan response error yang tepat akan dikirim kembali ke user.
- Jika kegagalan validasi terjadi pada HTTP Request tradisional, maka sebuah response redirect ke URL sebelumnya akan di buat.
- Dan jika request berupa XHR Request, maka response JSON yang berisi pesan error validasi akan direturn.
- Baiklah, mari kita isi method store() kita :

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'title' => 'required|unique:posts|max:255',
            'body' => 'required'
        ]);

        // logic ketika post blog validasi

        return redirect('/posts);
    }

- Seperti yang bisa kita lihat diatas, bahwa aturan validasi telah di masukan kedalam method store.
- Kita tidak perlu khawatir tentang apa saja aturan validasi yang tersedia, karena semua aturan validasi telah di dokumentasikan.
- Dan juga, seperti yang dibahas sebelumnya, bahwa jika validasi gagal maka response yang tepat akan dibuat / digenerate, dan jika validasi lolos, maka controller kita (PostController) akan melanjutkan eksekusi kode secara normal.
- Sebagai alternatif kita bisa menentukan aturan validasi sebagai array daripada menggunakan string pemisah tunggal |. contoh :

    $validatedData = $request->validate([
        'title' => ['required', 'unique:posts', 'max:255'],
        'body' => ['required'],
    ]);

- Sebagai tambahan kita juga bisa menggunakan method validateWithBag() untuk memvalidasi sebuah request dan menyimpan setiap error kedalam tas error bernama. contoh :

    $validatedData = $request->validateWithBag('post',[
        'title' => ['required', 'unique:posts', 'max:255'],
        'body' => ['required'],
    ]);

# Memberhentikan pada kegagalan validasi pertama.
- Terkadang kita ingin menghentikan proses validasi pada suatu attribut, ketika terjadi kegagalan validasi pertama. artinya ketika suatu request tidak lolos validasi pertama kali pada suatu rules / aturan.
- Jika kita ingin melakukan hal ini, kita bisa menambahkan rules / aturan 'bail' ke attribute yang kita inginkan. contoh :

    $validated = $request->validate([
            'title' => 'bail|required|unique:posts|max:255',
            'body' => 'required'
    ]);

- Pada contoh diatas, jika aturan unique dari attribute 'title' tidak lolos, maka aturan 'max' tidak akan di cek.
- Aturan / rules akan diperiksa berdasarkan urutan mereka ditugaskan.

# Catatan pada Attribute bersarang.
- Jika HTTP Request yang masuk berisi bidang data yang bersarang, kita bisa menentukan bidang ini pada aturan validasi kita dengan menggunakan syntax 'dot' (.). contoh :

    $validatedData = $request->validate([
        'title' => 'bail|required|unique:posts|max:255',
        'author.name' => 'required',
        'author.description' => 'required',
    ]);

- Disisi lain jika nama bidang kita mengandung literal period (tanda titik), kita bisa mencegah agar tidak diartikan sebagai syntax dot (.) dengan meng-escape-nya dengan menggunakan tanda backslash(\). contoh :

    $validatedData = $request->validate([
        'title' => 'bail|required|unique:posts|max:255',
        'v1\.0' => 'required',
    ]);

# Menampilkan Error Validasi.
- Selanjutnya bagaimana jika bidang request yang masuk tidak lolos aturan validasi ?
- Seperti yang telah dijelaskan sebelumnya, bahwa laravel akan me-redirect user ke halaman sebelumnya, dan semua error validasi dan juga input request akan secara otomatis di flash ke session.
- Selain itu sebuah variable $errors juga akan dibagikan ke semua view dari aplikasi laravel kita, oleh middleware 'Illuminate\View\Middleware\ShareErrorsFromSession' yang mana disediakan oleh group middleware 'web'.
- Ketika ini diterapkan maka variabel $errors akan selalu tersedia di view kita, dan memungkinkan kita secara mudah mengasumsikan bahwa variabel $errors selalu didefinisikan dan dapat dengan aman di gunakan.
- dan variabel $errors akan menjadi bagian dari object 'Illuminate\Support\MessageBag'.
- Sehingga jika pada contoh kita sebelumnya, ketika validasi gagal (pada method store), user akan diredirect ke method create dari controller PostController kita, dan kita bisa menampilkan pesan error di view. contoh :

    <!-- /resources/views/post/create.blade.php -->
    <h1>Buat Postingan</h1>

    @if($errors->any())
        <div class="alert alert-danger">
            <ul>
                @foreach($errors->all() as $error)
                    <li> {{ $error }} </li>
                @endforeach
            </ul>
        </div>
    @endif

    <!-- Create Post Form -->

# Kustomisasi Pesan Error.
- Setiap aturan validasi bawaan laravel memiliki pesan error yang berlokasi di file 'lang/en/validation.php' dari aplikasi kita.
- Jika ketika kita membuat aplikasi laravel, folder / direktori tersebut tidak ditemukan, kita bisa memerintahkan ke laravel menggunakan perintah artisan 'php artisan lang:publish'.
- Didalam file lang/end/validation.php terdapat entri terjemahan untuk setiap aturan validasi, dan kita bebas mengubah / memodifikasinya sesuai dengan kebutuhan dari aplikasi kita.
- Sebagai tambahan, kita bisa menyalin folder ini ke direktori langaunge lain untuk menerjemahkan pesan untuk aplikasi kita.
- Note : secara default kerangka aplikasi laravel tidak menyertakan direktori lang, jika kita ingin mengkostumisasi bahasa file bahasa (langaunge) laravel, kita bisa mempublishnya melalui perintah artisan 'lang:publish'.

# Request dan Validasi XHR.
- Pada contoh yang sudah dibahas sebelumnya kita menggunakan form tradisional (klasik) untuk mengirim data ke aplikasi.
- Tapi banyak aplikasi juga menerima request dari Javascript yang berasal dari frontend.
- Laravel tidak akan menghasilkan response redirect ketika memvalidasi data dari request XHR, tapi akan menghasilkan sebuah response JSON yang berisi semua error validasi.
- Response JSON ini akan dikirimkan bersama dengan status kode HTTP 422.

# Directive @error
- Kita juga bisa menggunakan directive blade @error untuk secara cepat memeriksa apakah pesan error validasi untuk suatu attribute itu tersedia / tidak.
- Dengan directive blade @error kita bisa menampilkan pesan error yang ada, dengan mengechokan $message di dalamnya. contoh :

    <!-- /resources/views/post/create.blade.php -->
    <label for="title">Judul Postingan</label>
    <input type="text" name="title" id="title" class="@error('title') is-invalid @enderror">
    @error('title')
        <alert class="alert alert-danger">{{ $message }}</alert>
    @enderror

- Jika kamu menggunakan tas error bernama (named error bags) kita bisa memberikan tas error bernama sebagai argument ke 2 dari directive @error. contoh :

        <input type="text" name="title" id="title" class="@error('title', 'post') is-invalid @enderror">

# Mengisi Ulang Forms.
- Ketika laravel membuat sebuah response redirect karena kesalahan / error validasi, framework akan secara ototmatis mem-flash semua data input request ke session.
- Hal ini dilakukan agar kita bisa dengan mudah / nyaman mengakses data input selama request selanjutnya, dan juga mengisi ulang form yang telah user coba untuk submit.
- Untuk mengambil data input yang di flash dari request sebelumnya, panggil method old() pada object 'Illuminate\Http\Request'.
- Method old() akan menarik / mengambil semua data input yang di flash sebelumnya dari session. contoh :

    $title = $request->old('title');

- Laravel juga menyediakan global helper old() yang bisa kamu gunakan untuk menampilkan input lama di Blade Template.
- Dan akan lebih mudah untuk menggunakan helper method old() untuk mengisi ulang form, jika data lama tidak ada, makan null akan di return. contoh :

        <input type="text" name="title" value="{{ old('title') }}">

# Catatan untuk bidang opsional.
- Secara default laravel menyertakan middleware TrimStrings dan ConvertEmptyStringsToNull pada tumpukan middleware global aplikasi laravel kita.
- Dan karena hal ini kita akan sering, harus menandai bidang request opsional kita sebagai 'nullable', jika kita ingin validator menganggap nilai null sebagai invalid. contoh :

    $validated = $request->validate([
            'title' => 'bail|required|unique:posts|max:255',
            'body' => 'required',
            'publish_at' => 'nullable|date',
    ]);

- Pada contoh diatas kita menentukan bahwa bidang / field publish_at dapat berisi null atau representasi tanggal yang valid.
- Jika kita tidak menambahkan modifier 'nullable' ke definisi rule, maka validator akan menganggap null sebagai tanggal yang tidak valid(invalid).

# Format Response Validasi Error.
- Ketika aplikasi laravel kita melemparkan (throw) sebuah exception 'Illuminate\Exception\ValidationException' dan HTTP Request yang masuk mengharapkan response JSON, maka laravel akan secara otomatis memformat pesan error untuk kita, dan mengembalikan HTTP Response 422 Unprocessable Entity.
- Dibawah ini adalah contoh format response JSON untuk error validasi. yang perlu dicatat adalah bahwa key dari error bersarang diratakan dengan format notasi dot (.). contoh :

    {
        "message": "Nama team harus berupa string. (dan 4 error lainya.)",
        "errors": {
            "team_name": [
                "Nama team harus berupa string.",
                "Nama team harus berupa setidaknya satu karakter."
            ],
            "authorization.role": [
                "Authorization role yang dipilih tidak valid."
            ],
            "users.0.email": [
                "users.0.email dibutuhkan."
            ],
            "users.2.email": [
                "users.2.email harus berupa email yang valid."
            ]
        }
    }

# Validasi Form Request.
# Membuat form request.
- Jika kita ingin membuat sekenario validasi request yang lebih kompleks, kita bisa membuat sebuah form request.
- Form request adalah sebuah class request kustom yang merangkum logic validasi dan authorizai milik mereka sendiri.
- Untuk membuat sebuah class form request, kita bisa menggunakan perintah artisan 'make:request'. contoh :

    php artisan make:request StorePostRequest

- Class form request yang dihasilkan akan ditempatkan di direktori 'app/Http/Requests'.
- Jika aplikasi laravel kita tidak memiliki direktori tersebut, maka laravel akan membuatnya ketika kita menjalankan perintah artisan 'make:request'.
- Setiap class form request yang dihasilkan oleh laravel akan memiliki 2 method yaitu : authorize dan rules.
- Method authorize() bertanggung jawab untuk menentukan apakah user terkini yang terautentikasi dapat melakukan action yang diwakili oleh request.
- Sedangkan method rules() mengembalikan aturan / rules validasi yang harus kita terapkan ke data request. contoh method rules() :

    public function rules(): array
    {
        return [
            'title' => 'bail|required|unique:posts|max:255',
            'body' => 'required',
        ]
    }

- Kita juga bisa mengetikan dependencies apapun yang kita butuhkan di signature method rules, mereka akan secara otomatis di resolve oleh service container laravel.
- Selanjutnya bagaimana aturan validasi yang telah kita buat akan divalidasi (diterapkan) ?
- Kita hanya perlu menuliskan request ke method controller kita.
- Nantinya secara otomatis form request yang masuk akan di eksekusi sebelum method controller dieksekusi.
- Yang artinya kita tidak perlu mengacaukan method controller kita dengan logic validasi apapun. contoh :

    public function store(StorePostRequest $request): RedirectResponse
    {
        // mengambil semua data input yang divalidasi
        $validated = $request->validated();

        // mengambil sebagian data input yang divalidasi
        $validated = $request->safe()->only(['title', ]);
        $validated = $request->safe()->except(['author', 'subtitle']);

        // logic untuk menyimpan post blog

        // redirect user.
        return redirect('/posts');
    }

- Jika validasi gagal, maka response redirect akan dibuat yang akan mengembalikan user ke halaman sebelumnya.
- Dan error juga akan di flash ke session, sehingga mereka tersedia ketika kita ingin menampilkanya.
- Jika request berupa XHR, maka HTTP Response dengan status code 422 akan di return ke user dengan menyertakan representasi JSON dari error validasi.

# Melakukan Validasi Tambahan.
- Terkadang mungkin kita ingin melakukan validasi tambahan setelah validasi awal kita selesai / komplit.
- Jika kita inging melakukan hal ini, kita bisa menggunakan method after() milik form request.
- Method after() harus mengembalikan sebuah array yang berisi function closure / callable (function yang dapat dipanggil) yang akan dipanggil ketika validasi selesai.
- Callable / closure ini akan menerima sebuah object 'Illuminate\Validation\Validator' yang memungkinkan kita untuk memunculkan pesan error tambahan jika diperlukan. contoh :

    use Illuminate\Validation\Validator;

    public function after(): array
    {
        return [
            function(Validator $validator) {
                if($this->somethingElseIsInvalid()) {
                    $validator->errors()->add([
                        'field',
                        'Ada sesuatu yang salah pada field / bidang ini.'
                    ]);
                }
            }
        ];
    }

- Selain closure, array yang dikembalikan method after() juga berisi class yang dapat dipanggil (invokable class), yang mana method __invoke() dari class ini akan menerima object 'Illuminate\Validation\Validator'. contoh :

    use Illuminate\Validation\Validator;

    public function after(): array
    {
        return [
            new ValidateUserStatus,
            new ValidateShipingTime,
            function(Validator $validator) {
                if($this->somethingElseIsInvalid()) {
                    $validator->errors()->add([
                        'field',
                        'Ada sesuatu yang salah pada field / bidang ini.'
                    ]);
                }
            }
        ];
    }

# Berhenti pada kegagalan validasi pertama.
- dalam class form request yang kita buat, kita bisa menambahkan properti $stopOnFirstFailure yang berguna untuk memberitahukan ke class bahwa dia harus memberhentikan validasi pada semua attribute ketika terjadi kegagalan validasi pada suatu attribute. contoh :

    protected $stopOnFirstFailure = true;

# Kustomisasi Lokasi Redirect.
- Ketika validasi dari form request gagal, laravel akan menghasilkan sebuah response redirect yang akan mengirimkan user kembali ke halaman sebelumnya.
- Jika kita ingin mengkustomisasi perilaku ini (lokasi dari redirect), kita bisa mendefinisikan properti $redirect di dalam class form request kita. contoh :

    protected $redirect = '/dashboard';

- Atau jika kita ingin meredirect user ke route bernama, kita bisa menggunakan / mendefinisikan properti $redirectRoute. contoh :

    protected $redirectRoute = 'dashboard';

# Otorisasi Form Request.
- Seperti yang sudah dibahas sebelumnya bahwa di dalam class form request juga terdapat method authorize().
- Didalam method ini kita bisa menentukan apakah user yang diautentikasi benar benar memiliki otorisasi untuk mengubah resource yang diberikan.
- Sebagai contoh : kita bisa menentukan apakah seorang user itu adalah pemilik dari komentar blog yang sedang coba mereka perbarui.
- Didalam method ini kemungkinan kita akan sering berhadapan dengan kebijakan dan gerbang autorisasi. contoh :

    use App\Models\Comment;

    public function authorize(): bool
    {
        $comment = Comment::find($this->route('comment'));

        return $comment && $this->user()->can('update', $comment);
    }

- Pada contoh diatas, kita bisa memanggil method user() yang memungkinkan kita untuk mengakses user terkini yang sudah diautentikasi.
- Hal ini terjadi karena semua class form request itu meng-extends class request dasar laravel.
- Selanjutnya kita juga perhatikan pemanggilan method route(). Method ini memungkinkan kita untuk mengakses parameter yang didefinisikan pada route yang dipanggil.
- Sebagai contoh : kita bisa mengakses parameter {comment} dari route berikut :

    Route::get('/comment/{comment}');

- Jika aplikasi kita menggunakan / memanfaatkan route model binding, kita bisa membuat kode kita lebih effisien. contoh :

    use App\Models\Comment;

    public function authorize(): bool
    {
        $comment = Comment::find($this->route('comment'));

        return $this->user()->can('update', $this->comment);
    }

- Jika method authorize() mengembalikan 'false', maka HTTP Response dengan status code 403 akan direturn secara otomatis, dan method dari controller kita tidak akan dieksekusi.
- Jika mungkin kita ingin menangani logic otorisasi (authorization) dibagian lain dari aplikasi kita, kita dapat menghapus method authorize() sepenuhnya, atau lebih sederhananya kita bisa me-return true. contoh :

    public function authorize(): bool
    {
        return true;
    }

# Kustomisasi Pesan Error Form Request.
- Kita juga dapat mengkustomisasi pesan error dari class form request, yaitu dengan cara meng-overriding method messages().
- Method ini harus mengembalikan sebuah array yang berisi pasangan attribute - rules dan pesan error mereka yang sesuai. contoh :

    public function messages(): array
    {
        return [
            'title.required' => 'Judul ini tidak boleh kosong !',
            'body.required' => 'Body tidak boleh kosong !',
        ];
    }

# Kustomisasi Attribute Validasi.
- Kebanyakan pesan error dari rule validasi bawaan laravel itu berisi placeholder ':attribtue'.
- Jika kita ingin mengkustomisasi placeholder :attribute dari pesan validasi aplikasi kita dengan nama attribute custom, kita bisa melakukanya dengan mengoverride method attributes().
- Method attributes() harus mengembalikan sebuah array yang berisi  pasangan nama placeholder attribute dan nama custom placeholder. contoh :

    public function attributes(): array
    {
        return [
            'email' => 'alamat email',
        ];
    }
