# Pengelanan / Intro.
- Laravel menyediakan beberapa pendekatan yang berbeda untuk melakukan validasi terhadap data yang masuk ke aplikasi laravel kita.
- Yang paling umum adalah menggunakan method validat() yang tersedia di semua HTTP Request.
- Tapi pada pembahasan kali ini kita juga akan membahas pendekatan lain yang juga digunakan untuk melakukan validasi.
- Laravel menyertakan berbagai macam aturan validasi yang nyaman, yang bisa kita terapkan ke data, bahkan menyediakan kemampuan untuk melakukan validasi apakah suatu nilai dari table database itu unique.
- Pada pembahasan ini akan membahas setiap aturan validasi secara detail sehingga kita akan familiar dengan semua fitur validasi laravel.

# Quickstart validasi.
- Untuk mempelajari tentang fitur validasi laravel yang powerfull ini, kita akan melihat pada contoh validasi lengkap pada sebuah form dan menampilkan kembali pesan error ke user.
- Dengan membaca gambaran umum level tinggi ini, diharapkan kita bisa mendapatkan pemahaman dasar yang baik tentang bagaimana cara memvalidasi request yang masuk menggunakan laravel.

# Definisikan Route.
- Pertama mari kita asumsikan bahwa kita telah memiliki / mendefinisikan route berikut di file routes/web.php aplikasi laravel kita :

    use App\Http\Controller\PostController;

    Route::get('/post/create', [PostController::class, 'create']);
    Route::post('/post', [PostController::class, 'store']);

- Route 'get' akan menampilkan form ke user untuk membuat postingan blog baru, sedangkan Route 'post' digunakan untuk menyimpan postingan blog baru ke database.

# Membuat Controller.
- Selanjutnya mari kita lihat pada controller yang menangani request yang masuk ke route ini, dan untuk sementara kita akan membiarkan method store() kosong.

    <?php
    namespace App\Http\Controllers;

    class PostController extends Controller
    {
        public function create(): View
        {
            return view('post.create');
        }

        public function post(Request $request): RedirectResponse
        {
            // memvalidasi request
            $post = /** .. */
            return to_route('post.show',['post' => $post->id]);
        }
    }

# Menulis Logik Validasi.
- Sekarang saatnya kita mengisi method store() dengan logik yang digunakan untuk memvalidasi postingan blog baru.
- Kita akan menggunakan method validate() yang disediakan oleh object Illuminate\Http\Request.
- Jika aturan validasi lolos, maka kode kita akan dieksekusi secara normal, jika gagal, maka sebuah exception Illuminate\Validation\ValidationException akan di lempar(throw) dan response error yang tepat akan dikirim kembali ke user.
- Jika kegagalan validasi terjadi pada HTTP Request tradisional, maka sebuah response redirect ke URL sebelumnya akan di buat.
- Dan jika request berupa XHR Request, maka response JSON yang berisi pesan error validasi akan direturn.
- Baiklah, mari kita isi method store() kita :

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'title' => 'required|unique:posts|max:255',
            'body' => 'required'
        ]);

        // logic ketika post blog validasi

        return redirect('/posts);
    }

- Seperti yang bisa kita lihat diatas, bahwa aturan validasi telah di masukan kedalam method store.
- Kita tidak perlu khawatir tentang apa saja aturan validasi yang tersedia, karena semua aturan validasi telah di dokumentasikan.
- Dan juga, seperti yang dibahas sebelumnya, bahwa jika validasi gagal maka response yang tepat akan dibuat / digenerate, dan jika validasi lolos, maka controller kita (PostController) akan melanjutkan eksekusi kode secara normal.
- Sebagai alternatif kita bisa menentukan aturan validasi sebagai array daripada menggunakan string pemisah tunggal |. contoh :

    $validatedData = $request->validate([
        'title' => ['required', 'unique:posts', 'max:255'],
        'body' => ['required'],
    ]);

- Sebagai tambahan kita juga bisa menggunakan method validateWithBag() untuk memvalidasi sebuah request dan menyimpan setiap error kedalam tas error bernama. contoh :

    $validatedData = $request->validateWithBag('post',[
        'title' => ['required', 'unique:posts', 'max:255'],
        'body' => ['required'],
    ]);

# Memberhentikan pada kegagalan validasi pertama.
- Terkadang kita ingin menghentikan proses validasi pada suatu attribut, ketika terjadi kegagalan validasi pertama. artinya ketika suatu request tidak lolos validasi pertama kali pada suatu rules / aturan.
- Jika kita ingin melakukan hal ini, kita bisa menambahkan rules / aturan 'bail' ke attribute yang kita inginkan. contoh :

    $validated = $request->validate([
            'title' => 'bail|required|unique:posts|max:255',
            'body' => 'required'
    ]);

- Pada contoh diatas, jika aturan unique dari attribute 'title' tidak lolos, maka aturan 'max' tidak akan di cek.
- Aturan / rules akan diperiksa berdasarkan urutan mereka ditugaskan.

# Catatan pada Attribute bersarang.
- Jika HTTP Request yang masuk berisi bidang data yang bersarang, kita bisa menentukan bidang ini pada aturan validasi kita dengan menggunakan syntax 'dot' (.). contoh :

    $validatedData = $request->validate([
        'title' => 'bail|required|unique:posts|max:255',
        'author.name' => 'required',
        'author.description' => 'required',
    ]);

- Disisi lain jika nama bidang kita mengandung literal period (tanda titik), kita bisa mencegah agar tidak diartikan sebagai syntax dot (.) dengan meng-escape-nya dengan menggunakan tanda backslash(\). contoh :

    $validatedData = $request->validate([
        'title' => 'bail|required|unique:posts|max:255',
        'v1\.0' => 'required',
    ]);

# Menampilkan Error Validasi.
- Selanjutnya bagaimana jika bidang request yang masuk tidak lolos aturan validasi ?
- Seperti yang telah dijelaskan sebelumnya, bahwa laravel akan me-redirect user ke halaman sebelumnya, dan semua error validasi dan juga input request akan secara otomatis di flash ke session.
- Selain itu sebuah variable $errors juga akan dibagikan ke semua view dari aplikasi laravel kita, oleh middleware 'Illuminate\View\Middleware\ShareErrorsFromSession' yang mana disediakan oleh group middleware 'web'.
- Ketika ini diterapkan maka variabel $errors akan selalu tersedia di view kita, dan memungkinkan kita secara mudah mengasumsikan bahwa variabel $errors selalu didefinisikan dan dapat dengan aman di gunakan.
- dan variabel $errors akan menjadi bagian dari object 'Illuminate\Support\MessageBag'.
- Sehingga jika pada contoh kita sebelumnya, ketika validasi gagal (pada method store), user akan diredirect ke method create dari controller PostController kita, dan kita bisa menampilkan pesan error di view. contoh :

    <!-- /resources/views/post/create.blade.php -->
    <h1>Buat Postingan</h1>

    @if($errors->any())
        <div class="alert alert-danger">
            <ul>
                @foreach($errors->all() as $error)
                    <li> {{ $error }} </li>
                @endforeach
            </ul>
        </div>
    @endif

    <!-- Create Post Form -->

# Kustomisasi Pesan Error.
- Setiap aturan validasi bawaan laravel memiliki pesan error yang berlokasi di file 'lang/en/validation.php' dari aplikasi kita.
- Jika ketika kita membuat aplikasi laravel, folder / direktori tersebut tidak ditemukan, kita bisa memerintahkan ke laravel menggunakan perintah artisan 'php artisan lang:publish'.
- Didalam file lang/end/validation.php terdapat entri terjemahan untuk setiap aturan validasi, dan kita bebas mengubah / memodifikasinya sesuai dengan kebutuhan dari aplikasi kita.
- Sebagai tambahan, kita bisa menyalin folder ini ke direktori langaunge lain untuk menerjemahkan pesan untuk aplikasi kita.
- Note : secara default kerangka aplikasi laravel tidak menyertakan direktori lang, jika kita ingin mengkostumisasi bahasa file bahasa (langaunge) laravel, kita bisa mempublishnya melalui perintah artisan 'lang:publish'.

# Request dan Validasi XHR.
- Pada contoh yang sudah dibahas sebelumnya kita menggunakan form tradisional (klasik) untuk mengirim data ke aplikasi.
- Tapi banyak aplikasi juga menerima request dari Javascript yang berasal dari frontend.
- Laravel tidak akan menghasilkan response redirect ketika memvalidasi data dari request XHR, tapi akan menghasilkan sebuah response JSON yang berisi semua error validasi.
- Response JSON ini akan dikirimkan bersama dengan status kode HTTP 422.

# Directive @error
- Kita juga bisa menggunakan directive blade @error untuk secara cepat memeriksa apakah pesan error validasi untuk suatu attribute itu tersedia / tidak.
- Dengan directive blade @error kita bisa menampilkan pesan error yang ada, dengan mengechokan $message di dalamnya. contoh :

    <!-- /resources/views/post/create.blade.php -->
    <label for="title">Judul Postingan</label>
    <input type="text" name="title" id="title" class="@error('title') is-invalid @enderror">
    @error('title')
        <alert class="alert alert-danger">{{ $message }}</alert>
    @enderror

- Jika kamu menggunakan tas error bernama (named error bags) kita bisa memberikan tas error bernama sebagai argument ke 2 dari directive @error. contoh :

        <input type="text" name="title" id="title" class="@error('title', 'post') is-invalid @enderror">

# Mengisi Ulang Forms.
- Ketika laravel membuat sebuah response redirect karena kesalahan / error validasi, framework akan secara ototmatis mem-flash semua data input request ke session.
- Hal ini dilakukan agar kita bisa dengan mudah / nyaman mengakses data input selama request selanjutnya, dan juga mengisi ulang form yang telah user coba untuk submit.
- Untuk mengambil data input yang di flash dari request sebelumnya, panggil method old() pada object 'Illuminate\Http\Request'.
- Method old() akan menarik / mengambil semua data input yang di flash sebelumnya dari session. contoh :

    $title = $request->old('title');

- Laravel juga menyediakan global helper old() yang bisa kamu gunakan untuk menampilkan input lama di Blade Template.
- Dan akan lebih mudah untuk menggunakan helper method old() untuk mengisi ulang form, jika data lama tidak ada, makan null akan di return. contoh :

        <input type="text" name="title" value="{{ old('title') }}">

# Catatan untuk bidang opsional.
- Secara default laravel menyertakan middleware TrimStrings dan ConvertEmptyStringsToNull pada tumpukan middleware global aplikasi laravel kita.
- Dan karena hal ini kita akan sering, harus menandai bidang request opsional kita sebagai 'nullable', jika kita ingin validator menganggap nilai null sebagai invalid. contoh :

    $validated = $request->validate([
            'title' => 'bail|required|unique:posts|max:255',
            'body' => 'required',
            'publish_at' => 'nullable|date',
    ]);

- Pada contoh diatas kita menentukan bahwa bidang / field publish_at dapat berisi null atau representasi tanggal yang valid.
- Jika kita tidak menambahkan modifier 'nullable' ke definisi rule, maka validator akan menganggap null sebagai tanggal yang tidak valid(invalid).

# Format Response Validasi Error.
- Ketika aplikasi laravel kita melemparkan (throw) sebuah exception 'Illuminate\Exception\ValidationException' dan HTTP Request yang masuk mengharapkan response JSON, maka laravel akan secara otomatis memformat pesan error untuk kita, dan mengembalikan HTTP Response 422 Unprocessable Entity.
- Dibawah ini adalah contoh format response JSON untuk error validasi. yang perlu dicatat adalah bahwa key dari error bersarang diratakan dengan format notasi dot (.). contoh :

    {
        "message": "Nama team harus berupa string. (dan 4 error lainya.)",
        "errors": {
            "team_name": [
                "Nama team harus berupa string.",
                "Nama team harus berupa setidaknya satu karakter."
            ],
            "authorization.role": [
                "Authorization role yang dipilih tidak valid."
            ],
            "users.0.email": [
                "users.0.email dibutuhkan."
            ],
            "users.2.email": [
                "users.2.email harus berupa email yang valid."
            ]
        }
    }

# Validasi Form Request.
# Membuat form request.
- Jika kita ingin membuat sekenario validasi request yang lebih kompleks, kita bisa membuat sebuah form request.
- Form request adalah sebuah class request kustom yang merangkum logic validasi dan authorizai milik mereka sendiri.
- Untuk membuat sebuah class form request, kita bisa menggunakan perintah artisan 'make:request'. contoh :

    php artisan make:request StorePostRequest

- Class form request yang dihasilkan akan ditempatkan di direktori 'app/Http/Requests'.
- Jika aplikasi laravel kita tidak memiliki direktori tersebut, maka laravel akan membuatnya ketika kita menjalankan perintah artisan 'make:request'.
- Setiap class form request yang dihasilkan oleh laravel akan memiliki 2 method yaitu : authorize dan rules.
- Method authorize() bertanggung jawab untuk menentukan apakah user terkini yang terautentikasi dapat melakukan action yang diwakili oleh request.
- Sedangkan method rules() mengembalikan aturan / rules validasi yang harus kita terapkan ke data request. contoh method rules() :

    public function rules(): array
    {
        return [
            'title' => 'bail|required|unique:posts|max:255',
            'body' => 'required',
        ]
    }

- Kita juga bisa mengetikan dependencies apapun yang kita butuhkan di signature method rules, mereka akan secara otomatis di resolve oleh service container laravel.
- Selanjutnya bagaimana aturan validasi yang telah kita buat akan divalidasi (diterapkan) ?
- Kita hanya perlu menuliskan request ke method controller kita.
- Nantinya secara otomatis form request yang masuk akan di eksekusi sebelum method controller dieksekusi.
- Yang artinya kita tidak perlu mengacaukan method controller kita dengan logic validasi apapun. contoh :

    public function store(StorePostRequest $request): RedirectResponse
    {
        // mengambil semua data input yang divalidasi
        $validated = $request->validated();

        // mengambil sebagian data input yang divalidasi
        $validated = $request->safe()->only(['title', ]);
        $validated = $request->safe()->except(['author', 'subtitle']);

        // logic untuk menyimpan post blog

        // redirect user.
        return redirect('/posts');
    }

- Jika validasi gagal, maka response redirect akan dibuat yang akan mengembalikan user ke halaman sebelumnya.
- Dan error juga akan di flash ke session, sehingga mereka tersedia ketika kita ingin menampilkanya.
- Jika request berupa XHR, maka HTTP Response dengan status code 422 akan di return ke user dengan menyertakan representasi JSON dari error validasi.

# Melakukan Validasi Tambahan.
- Terkadang mungkin kita ingin melakukan validasi tambahan setelah validasi awal kita selesai / komplit.
- Jika kita inging melakukan hal ini, kita bisa menggunakan method after() milik form request.
- Method after() harus mengembalikan sebuah array yang berisi function closure / callable (function yang dapat dipanggil) yang akan dipanggil ketika validasi selesai.
- Callable / closure ini akan menerima sebuah object 'Illuminate\Validation\Validator' yang memungkinkan kita untuk memunculkan pesan error tambahan jika diperlukan. contoh :

    use Illuminate\Validation\Validator;

    public function after(): array
    {
        return [
            function(Validator $validator) {
                if($this->somethingElseIsInvalid()) {
                    $validator->errors()->add([
                        'field',
                        'Ada sesuatu yang salah pada field / bidang ini.'
                    ]);
                }
            }
        ];
    }

- Selain closure, array yang dikembalikan method after() juga berisi class yang dapat dipanggil (invokable class), yang mana method __invoke() dari class ini akan menerima object 'Illuminate\Validation\Validator'. contoh :

    use Illuminate\Validation\Validator;

    public function after(): array
    {
        return [
            new ValidateUserStatus,
            new ValidateShipingTime,
            function(Validator $validator) {
                if($this->somethingElseIsInvalid()) {
                    $validator->errors()->add([
                        'field',
                        'Ada sesuatu yang salah pada field / bidang ini.'
                    ]);
                }
            }
        ];
    }

# Berhenti pada kegagalan validasi pertama.
- dalam class form request yang kita buat, kita bisa menambahkan properti $stopOnFirstFailure yang berguna untuk memberitahukan ke class bahwa dia harus memberhentikan validasi pada semua attribute ketika terjadi kegagalan validasi pada suatu attribute. contoh :

    protected $stopOnFirstFailure = true;

# Kustomisasi Lokasi Redirect.
- Ketika validasi dari form request gagal, laravel akan menghasilkan sebuah response redirect yang akan mengirimkan user kembali ke halaman sebelumnya.
- Jika kita ingin mengkustomisasi perilaku ini (lokasi dari redirect), kita bisa mendefinisikan properti $redirect di dalam class form request kita. contoh :

    protected $redirect = '/dashboard';

- Atau jika kita ingin meredirect user ke route bernama, kita bisa menggunakan / mendefinisikan properti $redirectRoute. contoh :

    protected $redirectRoute = 'dashboard';

# Otorisasi Form Request.
- Seperti yang sudah dibahas sebelumnya bahwa di dalam class form request juga terdapat method authorize().
- Didalam method ini kita bisa menentukan apakah user yang diautentikasi benar benar memiliki otorisasi untuk mengubah resource yang diberikan.
- Sebagai contoh : kita bisa menentukan apakah seorang user itu adalah pemilik dari komentar blog yang sedang coba mereka perbarui.
- Didalam method ini kemungkinan kita akan sering berhadapan dengan kebijakan dan gerbang autorisasi. contoh :

    use App\Models\Comment;

    public function authorize(): bool
    {
        $comment = Comment::find($this->route('comment'));

        return $comment && $this->user()->can('update', $comment);
    }

- Pada contoh diatas, kita bisa memanggil method user() yang memungkinkan kita untuk mengakses user terkini yang sudah diautentikasi.
- Hal ini terjadi karena semua class form request itu meng-extends class request dasar laravel.
- Selanjutnya kita juga perhatikan pemanggilan method route(). Method ini memungkinkan kita untuk mengakses parameter yang didefinisikan pada route yang dipanggil.
- Sebagai contoh : kita bisa mengakses parameter {comment} dari route berikut :

    Route::get('/comment/{comment}');

- Jika aplikasi kita menggunakan / memanfaatkan route model binding, kita bisa membuat kode kita lebih effisien. contoh :

    use App\Models\Comment;

    public function authorize(): bool
    {
        $comment = Comment::find($this->route('comment'));

        return $this->user()->can('update', $this->comment);
    }

- Jika method authorize() mengembalikan 'false', maka HTTP Response dengan status code 403 akan direturn secara otomatis, dan method dari controller kita tidak akan dieksekusi.
- Jika mungkin kita ingin menangani logic otorisasi (authorization) dibagian lain dari aplikasi kita, kita dapat menghapus method authorize() sepenuhnya, atau lebih sederhananya kita bisa me-return true. contoh :

    public function authorize(): bool
    {
        return true;
    }

# Kustomisasi Pesan Error Form Request.
- Kita juga dapat mengkustomisasi pesan error dari class form request, yaitu dengan cara meng-overriding method messages().
- Method ini harus mengembalikan sebuah array yang berisi pasangan attribute - rules dan pesan error mereka yang sesuai. contoh :

    public function messages(): array
    {
        return [
            'title.required' => 'Judul ini tidak boleh kosong !',
            'body.required' => 'Body tidak boleh kosong !',
        ];
    }

# Kustomisasi Attribute Validasi.
- Kebanyakan pesan error dari rule validasi bawaan laravel itu berisi placeholder ':attribtue'.
- Jika kita ingin mengkustomisasi placeholder :attribute dari pesan validasi aplikasi kita dengan nama attribute custom, kita bisa melakukanya dengan mengoverride method attributes().
- Method attributes() harus mengembalikan sebuah array yang berisi  pasangan nama placeholder attribute dan nama custom placeholder. contoh :

    public function attributes(): array
    {
        return [
            'email' => 'alamat email',
        ];
    }

# Mempersiapkan Input untuk Validasi.
- Ketika kita mungkin perlu membersihkan atau mempersiapkan data dari request sebelum menerapkan rules validasi, kita bisa menggunakan method prepareForValidation(). contoh :

    protected function prepareForValidation(): void
    {
        $this->merge([
            'slug' => Str::slug($this->slug);
        ]);
    }

- Begitu juga ketika kita perlu menormalisasikan data request apapun setelah proses validasi selesai, kita bisa gunakan method passedValidation(). contoh :

    protected function passedValidation(): void
    {
        $this->replace([
            'name' => 'Adam'
        ]);
    }

# Membuat Validator secara Manual.
- Jika kita tidak ingin menggunakan method validate() yang ada pada object request, kita bisa membuat object Validator kita sendiri, yaitu dengan menggunakan facade Validator.
- Method make() yang ada pada facade Validator akan men-generate / membuatkan object validator baru. contoh :

    public function store(Request $request): RedirectResponse
    {
        $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        if($validator->fails()){
            redirect('/post/create')
                ->withErrors($validator)
                ->withInput();
        };

        // Mengambil semua data yang sudah divalidasi
        $validated = $validator->validated();

        // Mengambil beberapa bagian data saja
        $someValidated = $validator->safe()->only('author', 'post');
        $someValidated = $validator->safe()->except('author', 'post');

        return redirect('/posts');
    }

- Argument pertama yang diberikan pada method make() adalah data request yang akan divalidasi.
- Sedangkan argument ke2 adalah array dari aturan validasi yang akan diterapkan ke data request.
- Setelah kita menentukan apakah terdapat kegagalan pada validasi request, kita dapat menggunakan method withErrors() untuk mem-flash semua error ke session.
- Selain itu variable $errors secara otomatis juga akan tersedia di semua view dari aplikasi kita setelah redirect, yang memungkinkan kita untuk menampilkanya kembali ke user.
- Method withErrors() menerima sebuah object validator, errorBags, atau array PHP.

# Berhenti pada Kegagalan Validasi Pertama.
- Jika kita ingin menghentikan validasi pada semua attribute ketika terjadi kegagalan validasi tunggal, kita bisa menggunakan method stopOnFirstFailure() pada object validator. contoh :

    if($validator->stopOnFirstFailure()->fails()) {
        // action
    }

- Jika kita ingin membuat object validator secara manual, tapi tetap ingin memanfaatkan auto redirect dari method validate() dari HTTP Request, kita bisa memanggil method validate pada object validator yang ada. contoh :

    $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ])->validate();

- Jika validasi gagal, maka user akan secara otomatis di redirect, atau jika dalam kasus request XHR, maka sebuah response JSON akan di return.
- Jika kita ingin menyimpan errors kedalam tas error bernama (named errors bag) jika terjadi kegagalan validasi, kita bisa menggunakan method validateWithBag(). contoh :

    $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ])->validateWithBag('post');

# Tas Error Bernama.
- Ketika kita punya banyak form dalam satu halaman web, dan kita ingin memberikan nama untuk errorbag yang berisi error validasi, sehingga memungkinkan kita untuk mengambil pesan error untuk form tertentu.
- Untuk melakukan ini kita bisa memberikan nama sebagai argument ke2 dari method withErrors(). contoh :

    return redirect('/dashboard')->withErrors($validator, 'login');

- dan selanjutnya kita bisa mengakses object MessageBag bernama dari variable $errors sebagai berikut :

    {{ $errors->login->first('email') }}

# Pesan Error Kustom.
- Jika kita mau, kita bisa menyediakan pesan error kustom (buatan sendiri) yang harus object validator gunakan, daripada menggunakan pesan error bawaan laravel.
- Terdapat beberapa cara untuk melakukan hal ini. Pertama kita bisa memberikan pesan custom sebagai argument ke 3 dari method Validator::make(). contoh :

    $validator = Validator::make(request->all(), $rules, [
        'required' => ':attribute ini tidak boleh kosong !'
    ]);

- Placeholder :attribute pada contoh diatas akan digantikan dengan nama sebenarnya dari bidang / field yang sedang di validasi.
- Selain itu kita juga bisa menggunakan placeholder holder lain di pesan validasi. contoh :

    $messages = [
        'same' => 'bidang :attribtue harus sama dengan :other !',
        'size' => 'bidang :attribute harus benar benar bernilai :size',
        'between' => 'nilai :attribute harus berada diantara :min - :max',
        'in' => ':attribute harus berpa salah satu dari nilai : :values'
    ];

# Menentukan Pesan Custom untuk Attribute yang diberikan.
- Jika kita ingin menentukan pesan error custom untuk attribute tertentu, kita dapat melakukanya dengan menggunakan notasi dot (.).
- Caranya adalah dengan tentukan terlebih dahulu nama attributenya, notasi dot, lalu rule validasinya. contoh :

    $messages = [
        'email.required' => ':attribute harus berisi data email yang valid !',
    ];

# Menentukan Nilai Custom Attribute.
- Kebanyakan pesan error bawaan laravel menyertakan placeholder :attribute yang akan digantikan dengan nama bidang atau attribute yang sedang divalidasi.
- Jika kita ingin mengkustom nilai yang digunakan untuk menggantikan placeholder ini untuk bidang tertentu, kita bisa memberikan array yang berisi attribute custom sebagai argument ke 4 dari method Validator::make(). contoh :

    $validator = Validator::make($request->all(), $rules, $messages, [
        'email' => 'alamat email'
    ]);

# Melakukan Validasi Tambahan pada Validator yang dibuat secara Manual.
- Terkadang kita mungkin harus melakukan validasi tambahan setelah validasi pertama selesai.
- Untuk mencapai ini kita bisa menggunakan method after().
- Method after() menerima closure / callable(sesuatu yang dapat dipanggil) yang akan dipanggil setelah validasi selesai.
- Callable / closure yang diberikan akan menerima sebuah object Illuminate\Validation\Validator yang mana memungkinkan kita untuk meningkatkan pesan error tambahan jika dibutuhkan. contoh :

    $validator = Validator::make($data, $rules, $messages, $attr);

    $validator->after(function($validator){
        if($this->somethingElseIsInvalid()) {
            $validator->errors()->add(
                'field' => 'Ada yang salah dengan field ini !'
            );
        }
    });

    if($validator->fails() {
        // ...
    });

- Seperti yang disebutkan sebelumnya bahwa method after() juga menerima array yang berisi callable(sesuatu yang dapat dipanggil).
- Yang mana khususnya nyaman digunakan ketika logic dari validasi after kita di enkapsulasi (dibungkus) didalam sebuah class.
- Dimana class tersebut akan menerima object Illuminate\Validation\Validator di method __invoke() mereka.

    $validator = Validator::make($data, $rules, $messages, $attr);

    $validator->after(
        new ValidateUserStatus,
        new ValidateShipingTime,
        function($validator){
        if($this->somethingElseIsInvalid()) {
            $validator->errors()->add(
                'field' => 'Ada yang salah dengan field ini !'
            );
        }
    });

    if($validator->fails() {
        // ...
    });

# Bekerja dengan Input yang telah di Validasi.
- Setelah memvalidasi data request yang masuk menggunakan form request atau object validator yang dibuat secara manual, kita bisa mengambil data yang telah menjalani proses validasi dengan beberapa cara.
- Pertama kita bisa menggunakan method validated() dari form request atau object validator yang dibuat secara manual.
- Method ini akan mengembalikan array dari data yang telah divalidasi. contoh :

    $validated = $request->validated();

    $validated = $validator->validated();

- Sebagai alternatif kita bisa menggunakan method safe() dari form request atau object validator.
- Method ini akan mengembalikan sebuah object Illuminate\Support\ValidatedInput, dimana object ini akan mengekspos method only(), expect() dan all() yang akan mengambil sebagian atau bahkan seluruh array dari data yang divalidasi.

    $validated = $request->safe()->only(['name', 'username']);
    $validated = $request->safe()->except(['name', 'username']);
    $validated = $request->safe()->all();

- Sebagai tambahan, object Illuminate\Support\ValidatedInput juga dapat di iterasi dan diakses seperti halnya array. contoh :

    // iterasi layaknya array
    @foreach($request->safe() as $key => $value)
        // ..
    @endforeach

    // akses layaknya array
    $validated = $request->safe();
    $email = $validated['email'];

- Jika kita ingin menambahkan field(bidang) tambahan ke data yang sudah divalidasi, kita bisa memanggil method merge(). contoh :

    $validated = $request->safe()->merge(['name' => 'Zaidun Qoimun']);

- Sedangkan jika kita ingin mengambil data yang divalidasi sebagai object collection, kita bisa memanggil method collect(). contoh :

    $validated = $request->safe()->collect();

# Bekerja dengan Pesan Error.
- Setelah memanggil method errors() dari object validator, kita akan menerima object Illuminate\Support\MessageBag.
- Yang mana object ini memiliki berbagai macam method yang bisa kita gunakan untuk bekerja menggunakan pesan error.
- Variabel $errors akan secara otomatis dibuat tersedia(available) disemua views yang juga merupakan bagian dari class MessageBag.

# Mengambil Pesan Error Pertama untuk Field(bidang) tertentu.
- Jika kita ingin mengambil pesan error pertama untuk bidang yang diberikan / ditentukan kita bisa menggunakan method first(). contoh :

    $errors = $validator->errors();

    echo $errors->first('email');

# Mengambil semua pesan untuk bidang yang ditentukan.
- Ketika kita ingin mengambil array dari semua pesan untuk bidang yang ditentukan, kita bisa menggunakan method get(). contoh :

    @foreach($errors->get('email') as $message) {

    }

- Jika kita mungkin memvalidasi bidang form array, kita bisa mengambil semua pesan error dari setiap element array menggunakan karakter bintang (*). contoh :

    @foreach($errors->get('attachments.*') as $message) {
        // ..
    }

# Mengambil semua pesan error dari semua field(bidang).
- Ketika kita ingin mengambil semua pesan error dari semua field(bidang), kita bisa menggunakan method all(). contoh :

    @foreach($errors->all() as $message) {
        // ...
    }

# Menentukan apakah sebuah pesan error untuk sebuah field itu tersedia / tidak.
- Dengan method has() kita bisa menentukan apakah pesan error untuk sebuah bidang itu ada. contoh :

    @if($errors->has('email')) {
        // ...
    }

# Menentukan Pesan Custom di file Langauge.
- Setiap aturan validasi bawaan laravel memiliki pesan error yang berlokasi di file 'lang/en/validation.php'.
- Jika aplikasi laravel yang kita buat tidak memiliki direktori tersebut(lang), kita bisa mengintruksikan ke laravel untuk membuatnya menggunakan perintah artisan lang:publish.
- Didalam file 'lang/en/validation.php' kita akan menemukan entri terjemahan untuk setiap aturan validasi.
- Kita bebas untuk memodifikasi / merubah pesan tersebut berdasarkan kebutuhan dari aplikasi kita.
- Sebagai tambahan kita bisa menyalin(copy) file ini ke dalam direktori direktori langauge lain untuk menerjemahkan pesan untuk bahasa aplikasi kita.
- Secara default kerangka kerja laravel tidak menyertakan direktori 'lang', jika kita ingin melakukan kustomisasi file langauge laravel, kita bisa mempublish-nya menggunakan perintah artisan lang:publish.

# Kustom Pesan untuk Attribute Spesifik.
- Kita bisa melakukan kustomisasi terhadap pesan error yang digunakan untuk kombinasi attribute dan rule didalam file langauge dari validasi aplikasi laravel kita.
- Untuk melakukanya tambahkan pesan kustom kita ke dalam array 'custom' dari file 'lang/xx/validation.php' dari aplikasi laravel kita. contoh :

    'custom' => [
        'email' => [
            'required' => 'Email wajib diisi !',
            'unique' => 'Email sudah digunakan !'
        ],
    ]
